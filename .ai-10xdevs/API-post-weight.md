# API Endpoint Implementation Plan: POST /api/dietitian/patients/:patientId/weight\n\n## 1. Przegląd punktu końcowego\n\nDodanie wpisu wagi przez dietetyka w imieniu pacjenta. Endpoint tworzy nowy rekord w `weight_entries` z metadanymi (źródło: `dietitian`, backfill/outlier), audytem i zdarzeniem analitycznym. Wspiera unikalność jednego wpisu dziennie na pacjenta (Europa/Warsaw) i wykrywanie anomalii (>3 kg w ≤48h).\n\nPowiązania z istniejącym kodem:\n- Reuse: `WeightEntryService.createWeightEntry(...)`\n- Reuse: `createWeightEntrySchema` (walidacja body)\n- Reuse: `getPatientDetailsParamsSchema` (walidacja param `patientId`)\n- Reuse: `weightEntryRepository.createEntry(...)`\n\n## 2. Szczegóły żądania\n\n- Metoda HTTP: POST\n- Struktura URL: `/api/dietitian/patients/:patientId/weight`\n- Parametry:\n  - Wymagane (path):\n    - `patientId` (UUID v4) – ID pacjenta, dla którego dodajemy wpis.\n  - Opcjonalne (query): brak\n- Nagłówki:\n  - `Content-Type: application/json`\n  - Cookie sesyjny Lucia (autoryzacja przez `locals.user`)\n- Request Body (JSON):\n  - `weight: number` (w kg; 30.0–250.0; maks. 1 miejsce po przecinku)\n  - `measurementDate: string` (ISO 8601; nie w przyszłości; max 7 dni wstecz)\n  - `note?: string` (opcjonalnie; maks. 200 znaków)\n\nPrzykład:\n\n```json\n{\n  \"weight\": 76.2,\n  \"measurementDate\": \"2025-10-30T08:00:00+02:00\",\n  \"note\": \"Reported via phone consultation\"\n}\n```\n\n## 3. Wykorzystywane typy\n\n- DTO (z `src/types.ts`):\n  - `CreateWeightEntryDietitianRequest`\n  - `CreateWeightEntryDietitianResponse`\n  - `WeightEntryDTO` (pośrednio)\n  - `ApiError`\n- Command Models (z `src/types.ts`):\n  - `CreateWeightEntryCommand` (userId = `patientId`, source = `'dietitian'`, createdBy = `dietitianId`)\n\n## 3. Szczegóły odpowiedzi\n\n- Status: `201 Created`\n- Body (JSON): zgodne z `CreateWeightEntryDietitianResponse`\n  - `entry`: { id, userId, weight:number, measurementDate:Date, source:'dietitian', isBackfill:boolean, isOutlier:boolean, outlierConfirmed:boolean|null, note:string|null, createdAt:Date, createdBy:string }\n\nPrzykład:\n\n```json\n{\n  \"entry\": {\n    \"id\": \"uuid\",\n    \"userId\": \"patient_uuid\",\n    \"weight\": 76.2,\n    \"measurementDate\": \"2025-10-30T06:00:00.000Z\",\n    \"source\": \"dietitian\",\n    \"isBackfill\": false,\n    \"isOutlier\": false,\n    \"outlierConfirmed\": null,\n    \"note\": \"Reported via phone consultation\",\n    \"createdAt\": \"2025-10-30T12:00:00.000Z\",\n    \"createdBy\": \"dietitian_uuid\"\n  }\n}\n```\n\nKody statusu:\n- 201 Created – utworzono wpis\n- 400 Bad Request – reguły biznesowe (np. backfill > 7 dni)\n- 401 Unauthorized – brak sesji\n- 403 Forbidden – rola inna niż `dietitian`\n- 404 Not Found – pacjent nie istnieje lub nie ma roli `patient`\n- 409 Conflict – wpis już istnieje dla tej daty\n- 422 Unprocessable Entity – walidacja Zod (body/path)\n- 500 Internal Server Error – błąd serwera\n\n## 4. Przepływ danych\n\n1. Autentykacja: odczyt `locals.user` (Lucia) → 401 jeśli brak.\n2. Autoryzacja: `user.role === 'dietitian'` → 403 jeśli inna rola.\n3. Walidacja paramów ścieżki: `getPatientDetailsParamsSchema` (UUID `patientId`) → 400/422 na błąd.\n4. Walidacja body: `createWeightEntrySchema` → 422 na błąd.\n5. Weryfikacja pacjenta: sprawdź istnienie i rolę `patient` (np. `userRepository.findById(patientId)` lub dedykowany helper) → 404 jeśli brak.\n6. Przygotowanie `CreateWeightEntryCommand`:\n   - `userId = patientId`\n   - `weight = body.weight`\n   - `measurementDate = new Date(body.measurementDate)`\n   - `source = 'dietitian'`\n   - `note = body.note`\n   - `createdBy = dietitianId (locals.user.id)`\n7. Business logic: `weightEntryService.createWeightEntry(command)`\n   - Walidacja backfill (≤7 dni), duplikat, backfill flag, wykrycie outlier.\n   - Wstawienie rekordu przez repozytorium.\n8. Audyt (asynchronicznie, best-effort):\n   - `auditLogRepository.create({ userId: dietitianId, action: 'create', tableName: 'weight_entries', recordId: entry.id, before: null, after: { weight, measurementDate, note, source: 'dietitian' } })`\n9. Analityka (asynchronicznie, best-effort):\n   - `eventRepository.create({ userId: dietitianId, eventType: 'add_weight_dietitian', properties: { patientId, entryId } })`\n10. Mapowanie odpowiedzi: konwersja `weight` ze string → number.\n11. 201 + JSON.\n\n## 5. Względy bezpieczeństwa\n\n- Uwierzytelnianie: sesje Lucia (cookie httpOnly, sameSite).\n- Autoryzacja: tylko `dietitian` na tym endpointzie.\n- RBAC (relacja dietetyk–pacjent):\n  - MVP: brak twardej weryfikacji przypisania (jak w innych miejscach – TODO).\n  - Plan: dodać helper `canAccessPatient(dietitianId, patientId)` i egzekwować 403, gdy brak relacji.\n- Walidacja danych: Zod + dodatkowe reguły w Service Layer, unikanie IDOR (ścieżka zawiera patientId, ale brak ujawniania cudzych danych).\n- Ochrona przed duplikacją: unikalny indeks „one per day” (Europe/Warsaw) + check w serwisie.\n- Brak rate limiting w MVP (zgodnie z tech stack), ale można dodać post‑MVP.\n- Logowanie: bez wrażliwych danych w logach; audyt i eventy rozdzielone.\n\n## 6. Obsługa błędów\n\n- Walidacja Zod (body/path): 422 `validation_error` + `details` (lista pól i komunikatów).\n- `BackfillLimitError`: 400 `backfill_limit_exceeded` (mapowane lokalnie).\n- `DuplicateEntryError`: 409 `duplicate_entry`.\n- Autentykacja: 401 `unauthorized`.\n- Autoryzacja: 403 `forbidden`.\n- Pacjent nie istnieje/rola ≠ patient: 404 `resource_not_found`.\n- Nieoczekiwane: 500 `internal_server_error`.\n\nFormat `ApiError`:\n```json\n{\n  \"error\": \"duplicate_entry\",\n  \"message\": \"Wpis wagi dla tej daty już istnieje.\",\n  \"statusCode\": 409\n}\n```\n\nRejestrowanie błędów:\n- `console.error` (MVP), bez PII.\n- Opcjonalnie: event `add_weight_failed` z kodem błędu (best‑effort), bez wrażliwych payloadów.\n\n## 7. Rozważania dotyczące wydajności\n\n- Operacja O(1) insert + kontrolne selecty; indeksy istnieją (`idx_one_entry_per_day`, `idx_weight_entries_user_date`).\n- Ogranicz zapytania: weryfikacja pacjenta lekkim repo (bez drogich agregacji – nie używać `patientService.getPatientDetails`).\n- Brak cache – operacja zapisu; ewentualnie cache read‑side endpointów.\n- Unikaj nadmiarowych konwersji czasu – korzystaj z istniejącego kodu (Europe/Warsaw w Service Layer).\n\n## 8. Etapy wdrożenia\n\n1. Utwórz endpoint:\n   - Plik: `src/pages/api/dietitian/patients/[patientId]/weight.ts`\n   - `export const prerender = false`\n2. Implementacja POST handlera:\n   - Pobierz `locals.user`; 401 jeśli brak.\n   - Sprawdź `user.role === 'dietitian'`; 403 jeśli nie.\n   - Zweryfikuj `params.patientId` przez `getPatientDetailsParamsSchema`; 422/400 na błąd.\n   - Odczytaj `request.json()` i zweryfikuj `createWeightEntrySchema`; 422 na błąd.\n   - Sprawdź pacjenta: `userRepository.findById(patientId)`; 404 jeśli brak lub rola ≠ `patient`.\n   - Zbuduj `CreateWeightEntryCommand` i wywołaj `weightEntryService.createWeightEntry(command)`.\n   - Zmapuj wynik do `CreateWeightEntryDietitianResponse` (konwersja `weight` na number).\n   - Zwróć `201 Created` + JSON.\n3. Obsługa błędów w `catch`:\n   - Zod → 422 z `details`.\n   - `DuplicateEntryError` → 409.\n   - `BackfillLimitError` → 400.\n   - `NotFoundError` pacjenta → 404.\n   - Inne → 500.\n4. Audyt i analityka (best‑effort):\n   - Po sukcesie, równolegle: `auditLogRepository.create(...)`, `eventRepository.create(...)` z `eventType: 'add_weight_dietitian'`.\n5. Testy ręczne i kontraktowe:\n   - Happy path: 201.\n   - 401/403 (brak sesji/zła rola).\n   - 404 (nieistniejący pacjent).\n   - 409 (duplikat tego samego dnia).\n   - 422 (niepoprawny body/path).\n   - 400 (backfill > 7 dni / przyszła data).\n6. Dokumentacja:\n   - Dodaj przykład żądania/odpowiedzi do README/API docs.\n\n### Szkic implementacji (wysoki poziom)\n\n```ts\n// src/pages/api/dietitian/patients/[patientId]/weight.ts\nexport const prerender = false\nexport const POST: APIRoute = async ({ params, request, locals }) => {\n  try {\n    const sessionUser = locals.user\n    if (!sessionUser) return jsonError(401, 'unauthorized', 'Musisz być zalogowany')\n    if (sessionUser.role !== 'dietitian') return jsonError(403, 'forbidden', 'Brak uprawnień')\n\n    const { patientId } = getPatientDetailsParamsSchema.parse({ patientId: params.patientId })\n    const body = createWeightEntrySchema.parse(await request.json())\n\n    const patient = await userRepository.findById(patientId)\n    if (!patient || patient.role !== 'patient') return jsonError(404, 'resource_not_found', 'Pacjent nie istnieje')\n\n    const command: CreateWeightEntryCommand = {\n      userId: patientId,\n      weight: body.weight,\n      measurementDate: new Date(body.measurementDate),\n      source: 'dietitian',\n      note: body.note,\n      createdBy: sessionUser.id,\n    }\n\n    const result = await weightEntryService.createWeightEntry(command)\n\n    // best-effort audit + analytics (nie blokuje odpowiedzi)\n    void auditLogRepository.create({ userId: sessionUser.id, action: 'create', tableName: 'weight_entries', recordId: result.entry.id, before: null, after: { weight: body.weight, measurementDate: command.measurementDate, note: body.note, source: 'dietitian' } })\n    void eventRepository.create({ userId: sessionUser.id, eventType: 'add_weight_dietitian', properties: { patientId, entryId: result.entry.id } })\n\n    return new Response(JSON.stringify({\n      entry: {\n        id: result.entry.id,\n        userId: result.entry.userId,\n        weight: parseFloat(result.entry.weight),\n        measurementDate: result.entry.measurementDate,\n        source: 'dietitian',\n        isBackfill: result.entry.isBackfill,\n        isOutlier: result.entry.isOutlier,\n        outlierConfirmed: result.entry.outlierConfirmed ?? null,\n        note: result.entry.note,\n        createdAt: result.entry.createdAt,\n        createdBy: result.entry.createdBy,\n      },\n    }), { status: 201, headers: { 'Content-Type': 'application/json' } })\n  } catch (error: any) {\n    // map Zod + domain errors → ApiError\n  }\n}\n```\n\nUwagi implementacyjne:\n- Zachować spójność stylu z `src/pages/api/weight.ts` (nagłówki, mapping, konwersje typów, `prerender=false`).\n- W `catch` odwzorować istniejący schemat obsługi błędów (w tym `details` dla Zod).*** End Patch``` json

